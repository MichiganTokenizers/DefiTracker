{% extends "base.html" %}

{% block title %}Cardano Liquidity Pools & Farms - YieldLife{% endblock %}

{% block extra_css %}
<style>
    #aprTable {
        margin-bottom: 0;
        background-color: transparent;
    }
    #aprTable th {
        border-top: none;
        border-bottom: 2px solid rgba(0,0,0,0.2);
        padding: 1rem;
        font-weight: 600;
        color: #1a1a1a;
        user-select: none;
        background-color: transparent;
    }
    #aprTable th:hover {
        color: #333;
    }
    #aprTable td {
        padding: 1rem;
        vertical-align: middle;
        border-bottom: 1px solid rgba(0,0,0,0.1);
        color: #1a1a1a;
        background-color: transparent;
    }
    #aprTable tbody tr:hover {
        background-color: rgba(0,0,0,0.05);
    }
    #singleAssetTable {
        margin-bottom: 0;
        background-color: transparent;
    }
    #singleAssetTable th {
        border-top: none;
        border-bottom: 2px solid rgba(0,0,0,0.2);
        padding: 1rem;
        font-weight: 600;
        color: #1a1a1a;
        background-color: transparent;
    }
    #singleAssetTable td {
        padding: 1rem;
        vertical-align: middle;
        border-bottom: 1px solid rgba(0,0,0,0.1);
        color: #1a1a1a;
        background-color: transparent;
    }
    #singleAssetTable tbody tr:hover {
        background-color: rgba(0,0,0,0.05);
    }
    .table-responsive {
        border-radius: 8px;
    }
    
    /* Multi-select dropdown styles */
    .multi-select-container {
        position: relative;
    }
    .multi-select-btn {
        width: 100%;
        text-align: left;
        background: #fff;
        border: 1px solid rgba(0,0,0,0.2);
        color: var(--carbon-black);
        padding: 0.5rem 1rem;
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .multi-select-btn:hover {
        border-color: var(--sea-green);
    }
    .multi-select-btn .count-badge {
        background: var(--accent-primary);
        color: #000;
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 0.8rem;
        font-weight: 600;
    }
    .multi-select-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: #fff;
        border: 1px solid rgba(0,0,0,0.2);
        border-radius: 6px;
        margin-top: 4px;
        max-height: 300px;
        overflow-y: auto;
        z-index: 1000;
        display: none;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    .multi-select-dropdown.show {
        display: block;
    }
    .multi-select-actions {
        display: flex;
        gap: 8px;
        padding: 8px 12px;
        border-bottom: 1px solid rgba(0,0,0,0.1);
    }
    .multi-select-actions button {
        flex: 1;
        padding: 4px 8px;
        font-size: 0.75rem;
        border-radius: 4px;
        border: 1px solid rgba(0,0,0,0.2);
        background: transparent;
        color: var(--text-secondary);
        cursor: pointer;
    }
    .multi-select-actions button:hover {
        background: var(--sea-green);
        color: #fff;
        border-color: var(--sea-green);
    }
    .multi-select-option {
        display: flex;
        align-items: center;
        padding: 8px 12px;
        cursor: pointer;
        transition: background 0.15s;
        color: var(--carbon-black);
    }
    .multi-select-option:hover {
        background: rgba(14, 135, 73, 0.1);
    }
    .multi-select-option input {
        margin-right: 10px;
        accent-color: var(--accent-primary);
    }
    .multi-select-option label {
        cursor: pointer;
        margin: 0;
        flex: 1;
    }
    
    /* Styled cards - sand dune theme */
    .chart-card-dark,
    .card-styled {
        background: radial-gradient(ellipse 100% 70% at 50% 50%, var(--sand-dune) 45%, transparent 92%) !important;
        border-radius: 12px;
    }
    .card-styled h5 {
        color: #1a1a1a;
    }
    .card-styled .text-muted {
        color: #333 !important;
    }
    
    /* APR Toggle Button Styles */
    .apr-toggle {
        display: flex;
        gap: 0;
    }
    .apr-toggle .btn-check + .btn {
        border: 1px solid var(--sea-green);
        color: var(--sea-green);
        font-size: 0.85rem;
        padding: 0.5rem 1rem;
        background: transparent;
    }
    .apr-toggle .btn-check + .btn:hover {
        background-color: rgba(14, 135, 73, 0.1);
    }
    .apr-toggle .btn-check:checked + .btn {
        background-color: var(--sea-green);
        border-color: var(--sea-green);
        color: white;
    }
    .apr-toggle .btn:first-of-type {
        border-radius: 6px 0 0 6px;
    }
    .apr-toggle .btn:last-of-type {
        border-radius: 0 6px 6px 0;
    }
    .apr-toggle .btn:not(:first-of-type):not(:last-of-type) {
        border-radius: 0;
    }

    /* Title card */
    .title-card {
        text-align: center;
    }
    .title-summary {
        font-size: 0.85rem;
        color: #555;
        line-height: 1.4;
        text-align: left;
    }
    .title-section-label {
        font-size: 1.25rem;
        font-weight: 600;
        color: #0033ad;
    }
    .title-protocols-label {
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    .title-protocol-name {
        font-size: 1.1rem;
        font-weight: 600;
        color: #1a1a1a;
    }
    .title-protocol-logo {
        height: 28px;
        width: auto;
    }
    .future-protocol-indicator {
        background: rgba(0,0,0,0.05);
        border-radius: 8px;
        padding: 8px 16px;
        border: 1px dashed rgba(0,0,0,0.2);
    }
    .future-protocol-plus {
        font-size: 1.5rem;
        color: rgba(0,0,0,0.3);
        font-weight: 300;
    }
    .future-protocol-text {
        font-size: 0.8rem;
        color: rgba(0,0,0,0.4);
    }
    .chart-title {
        margin: 0;
        font-size: 1.5rem;
        color: #1a1a1a;
        font-weight: 600;
    }
    .chart-subtitle {
        color: #555;
        font-size: 0.9rem;
        margin: 0;
    }
    
    /* Chart filters row */
    .chart-filters-row {
        padding-bottom: 1rem;
        border-bottom: 1px solid rgba(0,0,0,0.1);
    }
    .chart-filters-row .form-label {
        color: #1a1a1a;
        font-weight: 500;
        font-size: 0.85rem;
    }
    .chart-container {
        position: relative;
    }
    .chart-section-title {
        color: #1a1a1a;
        font-size: 1rem;
        font-weight: 600;
        margin: 0 0 0.75rem 0;
        text-align: left;
    }
    
    /* Connected cards - no gap between chart and table */
    .card-top {
        border-bottom-left-radius: 0;
        border-bottom-right-radius: 0;
        margin-bottom: 0;
    }
    .card-bottom {
        border-top-left-radius: 0;
        border-top-right-radius: 0;
        border-top: 1px solid rgba(0,0,0,0.1);
    }
    
    /* Reward Breakdown Pie Charts */
    .breakdown-sidebar {
        height: fit-content;
        position: sticky;
        top: 1rem;
    }
    .breakdown-sidebar h5 {
        border-bottom: 1px solid rgba(0,0,0,0.1);
        padding-bottom: 0.75rem;
        margin-bottom: 1rem;
    }
    .breakdown-card-wrapper {
        padding: 1rem;
        border-bottom: 1px solid rgba(0,0,0,0.1);
    }
    .breakdown-card-wrapper:last-child {
        border-bottom: none;
    }
    .breakdown-card-header {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.5rem;
    }
    .breakdown-card-header img {
        width: 24px;
        height: 24px;
        border-radius: 4px;
    }
    .breakdown-card-header h5 {
        margin: 0;
        font-size: 0.95rem;
        font-weight: 600;
        color: #1a1a1a;
        text-transform: capitalize;
    }
    .breakdown-card-meta {
        font-size: 0.7rem;
        color: #555;
        margin-left: auto;
    }
    .breakdown-content {
        display: flex;
        align-items: center;
        gap: 1rem;
    }
    .breakdown-chart-container {
        position: relative;
        width: 100px;
        height: 100px;
        flex-shrink: 0;
    }
    .breakdown-chart-center {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        pointer-events: none;
    }
    .breakdown-chart-center .swap-fee-label {
        font-size: 0.5rem;
        color: #555;
        text-transform: uppercase;
        letter-spacing: 0.3px;
    }
    .breakdown-chart-center .swap-fee-value {
        font-size: 0.65rem;
        font-weight: 600;
        color: #1a1a1a;
    }
    .breakdown-legend {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        flex: 1;
    }
    .breakdown-legend-item {
        display: flex;
        align-items: center;
        gap: 0.4rem;
        font-size: 0.7rem;
    }
    .breakdown-legend-color {
        width: 10px;
        height: 10px;
        border-radius: 2px;
        flex-shrink: 0;
    }
    .breakdown-legend-label {
        color: #333;
        flex: 1;
    }
    .breakdown-legend-value {
        font-weight: 600;
        color: #1a1a1a;
    }
    .breakdown-loading {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100px;
        color: #555;
        font-size: 0.85rem;
    }
    .breakdown-filter {
        margin-bottom: 0.75rem;
    }
    .breakdown-filter select {
        width: 100%;
        padding: 0.35rem 0.5rem;
        font-size: 0.75rem;
        border: 1px solid rgba(0,0,0,0.15);
        border-radius: 6px;
        background: #fff;
        color: var(--carbon-black);
        cursor: pointer;
    }
    .breakdown-filter select:focus {
        outline: none;
        border-color: var(--sea-green);
        box-shadow: 0 0 0 2px rgba(14, 135, 73, 0.15);
    }
    
    /* External HTML tooltip for pie charts */
    .chart-tooltip {
        position: fixed;
        background: rgba(0, 0, 0, 0.85);
        color: #fff;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 0.8rem;
        pointer-events: none;
        z-index: 99999;
        opacity: 0;
        transition: opacity 0.15s ease;
        white-space: nowrap;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    .chart-tooltip.visible {
        opacity: 1;
    }
</style>
{% endblock %}

{% block content %}
<!-- External tooltip container -->
<div id="pieChartTooltip" class="chart-tooltip"></div>

<!-- Save Chart Modal -->
<div class="modal fade" id="saveChartModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Save Chart</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div id="saveChartAlert" class="alert d-none" role="alert"></div>
                <form id="saveChartForm" onsubmit="handleSaveChart(event)">
                    <input type="hidden" id="chartType" value="multi_asset">
                    <div class="mb-3">
                        <label for="chartName" class="form-label">Chart Name</label>
                        <input type="text" class="form-control" id="chartName" required maxlength="100" 
                               placeholder="e.g., My Cardano LP Watchlist">
                    </div>
                    <div class="mb-3">
                        <div id="chartTypeIndicator" class="text-muted small">
                            üìä Saving: <strong>Multi Asset, One Measure</strong> chart
                        </div>
                    </div>
                    <button type="submit" class="btn btn-primary w-100">Save</button>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- Title Cards -->
<div class="row mb-3">
    <!-- Left card: Cardano + Summary -->
    <div class="col-md-6 mb-2 mb-md-0">
        <div class="card p-3 card-styled title-card h-100 d-flex justify-content-center">
            <div class="d-flex align-items-center">
                <img src="/static/cardano-symbol.svg" alt="Cardano" class="cardano-logo me-2" width="32" height="32">
                <span class="title-section-label me-3">Cardano</span>
                <p class="title-summary mb-0">Provide liquidity to earn trading fees and farm rewards on Cardano's top DEXs.</p>
            </div>
        </div>
    </div>
    <!-- Right card: Protocols -->
    <div class="col-md-6">
        <div class="card p-3 card-styled title-card h-100">
            <div class="d-flex align-items-center justify-content-start">
                <div class="me-3">
                    <span class="text-muted title-protocols-label">Protocols</span>
                    <div class="d-flex align-items-center mt-1 gap-4">
                        <div class="d-flex align-items-center">
                            <img src="/static/minswap-logo.png" alt="Minswap" class="title-protocol-logo me-1">
                            <span class="title-protocol-name">Minswap</span>
                        </div>
                        <div class="d-flex align-items-center">
                            <img src="/static/sundaeswap-logo.ico" alt="SundaeSwap" class="title-protocol-logo me-1">
                            <span class="title-protocol-name">SundaeSwap</span>
                        </div>
                        <div class="d-flex align-items-center">
                            <img src="/static/wingriders-logo.svg" alt="WingRiders" class="title-protocol-logo me-1">
                            <span class="title-protocol-name">WingRiders</span>
                        </div>
                    </div>
                </div>
                <div class="future-protocol-indicator d-flex align-items-center">
                    <span class="future-protocol-plus">+</span>
                    <span class="future-protocol-text ms-2">Growth incoming</span>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="row">
    <!-- Main content -->
    <div class="col-lg-8">
        <!-- Chart Card with Filters -->
        <div class="card p-4 chart-card-dark card-top">
            <h5 class="chart-section-title">Multi Asset, One Measure</h5>
            <!-- Filters -->
            <div class="chart-filters-row mb-3">
                <div class="row g-2 align-items-end">
                    <div class="col-md-2">
                        <label class="form-label">Time Range</label>
                        <select id="timeRange" class="form-select">
                            <option value="7">Last 7 Days</option>
                            <option value="30" selected>Last 30 Days</option>
                            <option value="90">Last 90 Days</option>
                            <option value="365">Last Year</option>
                        </select>
                    </div>
                    <div class="col-md-4">
                        <label class="form-label">Asset Filter</label>
                        <div class="multi-select-container" id="assetFilterContainer">
                            <button type="button" class="multi-select-btn" id="assetFilterBtn">
                                <span id="assetFilterLabel">Loading...</span>
                                <span class="count-badge" id="assetCount">0</span>
                            </button>
                            <div class="multi-select-dropdown" id="assetDropdown">
                                <div class="multi-select-actions">
                                    <button type="button" onclick="selectAllAssets()">Select All</button>
                                    <button type="button" onclick="deselectAllAssets()">Clear</button>
                                    <button type="button" onclick="selectDefaults()">Defaults</button>
                                </div>
                                <div id="assetOptions">
                                    <!-- Populated by JS -->
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <label class="form-label">APR Measure</label>
                        <div class="apr-toggle" role="group" id="aprToggle">
                            <input type="radio" class="btn-check" name="aprType" id="apr1d" value="1d">
                            <label class="btn" for="apr1d" title="1-day actual APR">1d</label>
                            <input type="radio" class="btn-check" name="aprType" id="apr7d" value="7d">
                            <label class="btn" for="apr7d" title="7-day average APR">7d Avg</label>
                            <input type="radio" class="btn-check" name="aprType" id="apr30d" value="30d" checked>
                            <label class="btn" for="apr30d" title="30-day average APR">30d Avg</label>
                        </div>
                    </div>
                    <div class="col-md-2 ms-auto d-flex align-items-end">
                        <button type="button" class="btn btn-login w-100" id="saveChartBtn" onclick="saveCurrentChart()">
                            Save Chart
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Chart Canvas -->
            <div class="chart-container" style="height: 400px;">
                <canvas id="aprChart"></canvas>
            </div>
        </div>
        
        <!-- Table Card (no margin between chart and table) -->
        <div class="card p-4 card-styled card-bottom">
            <div class="table-responsive">
                <table class="table table-hover" id="aprTable">
                    <thead>
                        <tr>
                            <th style="cursor: pointer;" onclick="sortTable(0)" id="th-0">Asset</th>
                            <th style="cursor: pointer;" onclick="sortTable(1)" id="th-1">APR (30d) ‚Üì</th>
                            <th style="cursor: pointer;" onclick="sortTable(2)" id="th-2">24h Change</th>
                            <th style="cursor: pointer;" onclick="sortTable(3)" id="th-3">Volume (1d)</th>
                        </tr>
                    </thead>
                    <tbody id="currentAprs">
                        <!-- Populated by JS -->
                    </tbody>
                </table>
            </div>
        </div>
        
        <!-- Single Asset Chart - Multiple Time Measures -->
        <div class="card p-4 chart-card-dark card-top mt-4">
            <h5 class="chart-section-title">One Asset, Multi Measures</h5>
            <!-- Filters -->
            <div class="chart-filters-row mb-3">
                <div class="row g-2 align-items-end">
                    <div class="col-md-2">
                        <label class="form-label">Time Range</label>
                        <select id="singleAssetTimeRange" class="form-select">
                            <option value="30" selected>Last 30 Days</option>
                            <option value="90">Last 90 Days</option>
                            <option value="365">Last Year</option>
                        </select>
                    </div>
                    <div class="col-md-4">
                        <label class="form-label">Select Asset</label>
                        <select id="singleAssetSelect" class="form-select">
                            <option value="">Loading assets...</option>
                        </select>
                    </div>
                    <div class="col-md-3">
                        <label class="form-label">Protocol</label>
                        <div class="multi-select-container" id="protocolFilterContainer">
                            <button type="button" class="multi-select-btn" id="protocolFilterBtn">
                                <span id="protocolFilterLabel">All Protocols</span>
                                <span class="count-badge" id="protocolCount">0</span>
                            </button>
                            <div class="multi-select-dropdown" id="protocolDropdown">
                                <div class="multi-select-actions">
                                    <button type="button" onclick="selectAllProtocols()">Select All</button>
                                    <button type="button" onclick="deselectAllProtocols()">Clear</button>
                                </div>
                                <div id="protocolOptions">
                                    <!-- Populated by JS -->
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-2 ms-auto d-flex align-items-end">
                        <button type="button" class="btn btn-login w-100" id="saveSingleAssetChartBtn" onclick="saveSingleAssetChart()">
                            Save Chart
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Chart Canvas -->
            <div class="chart-container" style="height: 350px;">
                <canvas id="singleAssetChart"></canvas>
            </div>
        </div>
        
        <!-- Single Asset Table -->
        <div class="card p-4 card-styled card-bottom">
            <div class="table-responsive">
                <table class="table table-hover" id="singleAssetTable">
                    <thead>
                        <tr>
                            <th>Protocol</th>
                            <th><span style="opacity: 0.6;">‚óè</span> 1-Day <small style="font-weight: 400; opacity: 0.7;">(solid)</small></th>
                            <th><span style="opacity: 0.6;">‚ñ≤</span> 7-Day <small style="font-weight: 400; opacity: 0.7;">(dashed)</small></th>
                            <th><span style="opacity: 0.6;">‚ñ†</span> 30-Day <small style="font-weight: 400; opacity: 0.7;">(dotted)</small></th>
                        </tr>
                    </thead>
                    <tbody id="singleAssetTableBody">
                        <tr><td colspan="4" class="text-center" style="color: #555;">Select an asset to view data</td></tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <!-- Pie charts sidebar - full height -->
    <div class="col-lg-4">
        <div class="card p-3 card-styled breakdown-sidebar">
            <div class="d-flex justify-content-between align-items-center mb-3">
                <h5 class="mb-0" style="color: #1a1a1a;">Yield Breakdown <small style="font-size: 0.7rem; color: #555;">(1d APR)</small></h5>
                <select id="breakdownDateFilter" class="form-select form-select-sm" style="width: auto; min-width: 140px;" onchange="renderBreakdownCharts()">
                    <option value="">Loading...</option>
                </select>
            </div>
            <div id="breakdownCharts">
                <div class="breakdown-loading">
                    <span>Loading...</span>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
const chain = "{{ chain }}";
const yieldType = "{{ yield_type }}";
let chart = null;
let currentSortColumn = 1;
let currentSortDirection = 'desc';
let allAssets = [];
let selectedAssets = new Set();
let selectedAprType = '30d'; // '1d', '7d', or '30d'

// Calculate moving average for APR data
function calculateAprMovingAverage(dataPoints, window) {
    if (window <= 1) return dataPoints;

    const result = [];
    for (let i = 0; i < dataPoints.length; i++) {
        const start = Math.max(0, i - window + 1);
        const windowData = dataPoints.slice(start, i + 1);

        // Average apr_1d values over the window
        const validValues = windowData.filter(d => d.apr_1d != null);
        if (validValues.length > 0) {
            const avgApr = validValues.reduce((sum, d) => sum + d.apr_1d, 0) / validValues.length;
            result.push({
                ...dataPoints[i],
                apr_avg: avgApr
            });
        }
    }
    return result;
}

// Protocol logo mapping
const protocolLogos = {
    'minswap': '/static/minswap-logo.png',
    'sundaeswap': '/static/sundaeswap-logo.ico',
    'wingriders': '/static/wingriders-logo.svg',
    'liqwid': '/static/liqwid-logo.png'
};

// Line styles per DEX
const protocolLineStyles = {
    'minswap': { borderDash: [], pointStyle: 'circle' },
    'sundaeswap': { borderDash: [5, 5], pointStyle: 'rect' },
    'wingriders': { borderDash: [2, 2], pointStyle: 'triangle' },
    'liqwid': { borderDash: [10, 5], pointStyle: 'star' }
};

// Color palette
const pairColors = [
    '#16a34a', '#2563eb', '#d97706', '#dc2626', '#7c3aed',
    '#db2777', '#0d9488', '#ea580c', '#6d28d9', '#0891b2',
    '#65a30d', '#e11d48', '#0f766e', '#c2410c', '#9333ea'
];
const pairColorMap = {};

// Default assets
const defaultAssets = [
    'NIGHT-ADA', 'NIGHT-USDM', 'NIGHT-USDA'
];

function isDefaultAsset(symbol) {
    return defaultAssets.some(d => 
        symbol === d || 
        symbol.toUpperCase() === d.toUpperCase() ||
        symbol.includes(d) || 
        d.includes(symbol)
    );
}

async function loadAssets() {
    const response = await fetch(`/api/${chain}/all/assets?yield_type=${yieldType}`);
    const rawAssets = await response.json();
    
    const symbolSet = new Set();
    rawAssets.forEach(a => symbolSet.add(a.symbol));
    allAssets = Array.from(symbolSet).map(s => ({ symbol: s }));
    
    const optionsContainer = document.getElementById('assetOptions');
    optionsContainer.innerHTML = '';
    
    allAssets.forEach(asset => {
        const isDefault = isDefaultAsset(asset.symbol);
        if (isDefault) {
            selectedAssets.add(asset.symbol);
        }
        
        const div = document.createElement('div');
        div.className = 'multi-select-option';
        div.innerHTML = `
            <input type="checkbox" id="asset-${asset.symbol}" value="${asset.symbol}" 
                   ${isDefault ? 'checked' : ''} onchange="toggleAsset('${asset.symbol}')">
            <label for="asset-${asset.symbol}">${asset.symbol}</label>
        `;
        optionsContainer.appendChild(div);
    });
    
    updateAssetLabel();
}

function toggleAsset(symbol) {
    if (selectedAssets.has(symbol)) {
        selectedAssets.delete(symbol);
    } else {
        selectedAssets.add(symbol);
    }
    updateAssetLabel();
    loadChart();
}

function selectAllAssets() {
    allAssets.forEach(asset => selectedAssets.add(asset.symbol));
    document.querySelectorAll('#assetOptions input').forEach(cb => cb.checked = true);
    updateAssetLabel();
    loadChart();
}

function deselectAllAssets() {
    selectedAssets.clear();
    document.querySelectorAll('#assetOptions input').forEach(cb => cb.checked = false);
    updateAssetLabel();
    loadChart();
}

function selectDefaults() {
    selectedAssets.clear();
    allAssets.forEach(asset => {
        const isDefault = isDefaultAsset(asset.symbol);
        const checkbox = document.getElementById(`asset-${asset.symbol}`);
        if (checkbox) checkbox.checked = isDefault;
        if (isDefault) selectedAssets.add(asset.symbol);
    });
    updateAssetLabel();
    loadChart();
}

function updateAssetLabel() {
    const label = document.getElementById('assetFilterLabel');
    const count = document.getElementById('assetCount');
    const size = selectedAssets.size;
    
    count.textContent = size;
    
    if (size === 0) {
        label.textContent = 'No assets selected';
    } else if (size === allAssets.length) {
        label.textContent = 'All assets';
    } else if (size <= 3) {
        label.textContent = Array.from(selectedAssets).slice(0, 3).join(', ');
    } else {
        label.textContent = Array.from(selectedAssets).slice(0, 2).join(', ') + ` +${size - 2} more`;
    }
}

function getSelectedAssets() {
    return Array.from(selectedAssets);
}

// Dropdown toggle
document.getElementById('assetFilterBtn').addEventListener('click', function(e) {
    e.stopPropagation();
    document.getElementById('assetDropdown').classList.toggle('show');
    // Close protocol dropdown if open
    document.getElementById('protocolDropdown').classList.remove('show');
});

document.addEventListener('click', function(e) {
    if (!document.getElementById('assetFilterContainer').contains(e.target)) {
        document.getElementById('assetDropdown').classList.remove('show');
    }
    if (!document.getElementById('protocolFilterContainer').contains(e.target)) {
        document.getElementById('protocolDropdown').classList.remove('show');
    }
});

let allHistoryData = [];

function getPairColor(symbol) {
    if (!pairColorMap[symbol]) {
        const colorIndex = Object.keys(pairColorMap).length % pairColors.length;
        pairColorMap[symbol] = pairColors[colorIndex];
    }
    return pairColorMap[symbol];
}

function updateAprLabels() {
    // Labels are now static since table shows both APR types
}

async function loadChart() {
    const days = document.getElementById('timeRange').value;
    const selected = getSelectedAssets();
    
    const url = `/api/${chain}/all/history?days=${days}&yield_type=${yieldType}`;
    
    const response = await fetch(url);
    allHistoryData = await response.json();
    
    let chartData = allHistoryData;
    if (selected.length > 0 && selected.length < allAssets.length) {
        chartData = allHistoryData.filter(d => selected.includes(d.symbol));
    } else if (selected.length === 0) {
        chartData = [];
    }
    
    if (chart) {
        chart.destroy();
        chart = null;
    }
    
    // Update labels
    updateAprLabels();
    
    const is1d = selectedAprType === '1d';
    
    const datasets = chartData.map((assetData) => {
        const protocol = assetData.protocol;
        const symbol = assetData.symbol;
        const version = assetData.version;
        const color = getPairColor(symbol);
        const lineStyle = protocolLineStyles[protocol] || { borderDash: [], pointStyle: 'circle' };
        
        const versionSuffix = version ? ` ${version}` : '';
        const label = `${symbol} (${protocol}${versionSuffix})`;
        
        // Select which APR field to use based on selected type
        let processedData;
        if (is1d) {
            // Use apr_1d only - no fallback to 30d
            processedData = assetData.data
                .filter(d => d.apr_1d != null)
                .map(d => ({
                    x: new Date(d.timestamp),
                    y: d.apr_1d
                }));
        } else if (selectedAprType === '7d') {
            // Calculate 7-day moving average from apr_1d data
            const smoothedData = calculateAprMovingAverage(assetData.data, 7);
            processedData = smoothedData
                .filter(d => d.apr_avg != null)
                .map(d => ({
                    x: new Date(d.timestamp),
                    y: d.apr_avg
                }));
        } else {
            // Use stored apr value (30-day)
            processedData = assetData.data
                .filter(d => d.apr != null)
                .map(d => ({
                    x: new Date(d.timestamp),
                    y: d.apr
                }));
        }
        
        return {
            label: label,
            data: processedData,
            borderColor: color,
            backgroundColor: color + '20',
            borderWidth: 2,
            borderDash: lineStyle.borderDash,
            pointStyle: lineStyle.pointStyle,
            tension: 0.4,
            fill: false
        };
    }).filter(ds => ds.data.length > 0);
    
    const aprTypeLabel = is1d ? '1-Day APR' : selectedAprType === '7d' ? '7-Day Avg APR' : '30-Day Avg APR';

    // Handle empty datasets gracefully
    const noDataMessage = datasets.length === 0
        ? (is1d ? 'No 1-day APR data available for selected assets' : 'No data available for selected assets')
        : null;
    
    const ctx = document.getElementById('aprChart').getContext('2d');
    chart = new Chart(ctx, {
        type: 'line',
        data: { datasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: noDataMessage || aprTypeLabel,
                    color: noDataMessage ? '#666' : '#1a1a1a',
                    font: { size: 14, weight: 'normal' },
                    padding: { bottom: 10 }
                },
                legend: {
                    display: datasets.length > 0,
                    labels: { 
                        color: '#1a1a1a',
                        usePointStyle: true,
                        padding: 15,
                        font: { size: 11 }
                    }
                },
                tooltip: {
                    callbacks: {
                        label: (context) => `${context.dataset.label}: ${context.parsed.y.toFixed(2)}%`
                    }
                }
            },
            scales: {
                x: {
                    type: 'time',
                    time: { unit: days <= 7 ? 'day' : days <= 30 ? 'day' : 'week' },
                    grid: { color: 'rgba(0, 0, 0, 0.15)' },
                    ticks: { color: '#1a1a1a' },
                    display: datasets.length > 0
                },
                y: {
                    beginAtZero: true,
                    grid: { color: 'rgba(0, 0, 0, 0.15)' },
                    ticks: {
                        color: '#1a1a1a',
                        callback: (value) => value + '%'
                    },
                    display: datasets.length > 0
                }
            }
        }
    });
    
    updateCurrentAprs(chartData);
}

function updateCurrentAprs(data) {
    const tbody = document.getElementById('currentAprs');
    tbody.innerHTML = '';
    
    const sortedData = data.map(assetData => {
        // Get data that has at least 30d APR
        const relevantData = assetData.data.filter(d => d.apr != null);
        
        if (relevantData.length === 0) return null;
        
        const latest = relevantData[relevantData.length - 1];
        if (!latest) return null;
        
        // Get both APR values and volume
        const apr1d = latest.apr_1d;
        const apr30d = latest.apr;
        const volume24h = latest.volume_24h;

        // Calculate 7-day average using the same method as the chart
        // Use the last point from the moving average calculation on full data
        let apr7d = null;
        const smoothed7d = calculateAprMovingAverage(assetData.data, 7);
        if (smoothed7d.length > 0) {
            apr7d = smoothed7d[smoothed7d.length - 1].apr_avg;
        }

        if (apr30d == null) return null;
        
        // Calculate 24h change based on 30d APR
        let change24h = null;
        if (relevantData.length > 1) {
            const now = new Date(latest.timestamp);
            const oneDayAgo = new Date(now - 24 * 60 * 60 * 1000);
            
            let closest = relevantData[0];
            let minDiff = Math.abs(new Date(closest.timestamp) - oneDayAgo);
            
            for (let point of relevantData) {
                const diff = Math.abs(new Date(point.timestamp) - oneDayAgo);
                if (diff < minDiff) {
                    minDiff = diff;
                    closest = point;
                }
            }
            
            if (closest.apr != null) {
                change24h = apr30d - closest.apr;
            }
        }
        
        return {
            symbol: assetData.symbol,
            protocol: assetData.protocol,
            version: assetData.version,
            apr1d: apr1d,
            apr7d: apr7d,
            apr30d: apr30d,
            tvl_usd: latest.tvl_usd,
            change24h: change24h,
            volume24h: volume24h
        };
    }).filter(x => x !== null);
    
    window.tableData = sortedData;
    applySortToTable();
}

function applySortToTable() {
    const tbody = document.getElementById('currentAprs');
    tbody.innerHTML = '';
    
    let sorted = [...window.tableData];
    
    const is1d = selectedAprType === '1d';
    const is7d = selectedAprType === '7d';

    sorted.sort((a, b) => {
        let aVal, bVal;

        switch(currentSortColumn) {
            case 0:
                aVal = a.symbol;
                bVal = b.symbol;
                const cmp = aVal.localeCompare(bVal);
                return currentSortDirection === 'asc' ? cmp : -cmp;
            case 1:
                aVal = is1d ? (a.apr1d ?? -Infinity) : is7d ? (a.apr7d ?? -Infinity) : (a.apr30d ?? -Infinity);
                bVal = is1d ? (b.apr1d ?? -Infinity) : is7d ? (b.apr7d ?? -Infinity) : (b.apr30d ?? -Infinity);
                return currentSortDirection === 'asc' ? aVal - bVal : bVal - aVal;
            case 2:
                aVal = a.change24h ?? -Infinity;
                bVal = b.change24h ?? -Infinity;
                return currentSortDirection === 'asc' ? aVal - bVal : bVal - aVal;
            case 3:
                aVal = a.volume24h ?? -Infinity;
                bVal = b.volume24h ?? -Infinity;
                return currentSortDirection === 'asc' ? aVal - bVal : bVal - aVal;
            default:
                return 0;
        }
    });
    
    // Update APR column header based on toggle
    const aprHeader = document.getElementById('th-1');
    if (aprHeader) {
        let aprText = is1d ? 'APR (1d)' : is7d ? 'APR (7d)' : 'APR (30d)';
        if (currentSortColumn === 1) {
            aprText += currentSortDirection === 'asc' ? ' ‚Üë' : ' ‚Üì';
        }
        aprHeader.textContent = aprText;
    }
    
    // Update other column headers for sort indicators
    for (let i = 0; i < 4; i++) {
        if (i === 1) continue; // APR header already updated above
        const th = document.getElementById(`th-${i}`);
        if (th) {
            let text = th.textContent.replace(/ [‚Üë‚Üì]/g, '');
            if (i === currentSortColumn) {
                text += currentSortDirection === 'asc' ? ' ‚Üë' : ' ‚Üì';
            }
            th.textContent = text;
        }
    }
    
    sorted.forEach(item => {
        const row = document.createElement('tr');
        
        let changeHtml = '<span style="color: #555;">-</span>';
        if (item.change24h !== null) {
            const changeColor = item.change24h >= 0 ? '#16a34a' : '#dc2626';
            const changeSymbol = item.change24h >= 0 ? '+' : '';
            changeHtml = `<span style="color: ${changeColor}; font-weight: 500;">${changeSymbol}${item.change24h.toFixed(2)}%</span>`;
        }
        
        const logo = protocolLogos[item.protocol] || '/static/default-logo.png';
        const versionStr = item.version ? ` ${item.version}` : '';
        const aprValue = is1d ? item.apr1d : is7d ? item.apr7d : item.apr30d;
        const aprDisplay = aprValue != null ? `${aprValue.toFixed(2)}%` : '-';
        const volumeDisplay = item.volume24h != null ? formatVolume(item.volume24h) : '-';
        
        row.innerHTML = `
            <td>
                <img src="${logo}" alt="${item.protocol}" title="${item.protocol}" style="width: 20px; height: 20px; margin-right: 8px; vertical-align: middle; border-radius: 4px;" onerror="this.style.display='none'">
                <strong>${item.symbol}${versionStr}</strong>
            </td>
            <td><span style="color: var(--carbon-black); font-size: 1.1rem; font-weight: 600;">${aprDisplay}</span></td>
            <td>${changeHtml}</td>
            <td style="color: #1a1a1a;">${volumeDisplay}</td>
        `;
        tbody.appendChild(row);
    });
}

function formatTimeAgo(date) {
    const seconds = Math.floor((new Date() - date) / 1000);
    
    if (seconds < 60) return 'Just now';
    if (seconds < 3600) return Math.floor(seconds / 60) + 'm ago';
    if (seconds < 86400) return Math.floor(seconds / 3600) + 'h ago';
    return Math.floor(seconds / 86400) + 'd ago';
}

function formatVolume(value) {
    if (value >= 1000000) {
        return '$' + (value / 1000000).toFixed(2) + 'M';
    } else if (value >= 1000) {
        return '$' + (value / 1000).toFixed(1) + 'K';
    } else {
        return '$' + value.toFixed(0);
    }
}

function sortTable(columnIndex) {
    if (currentSortColumn === columnIndex) {
        currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
    } else {
        currentSortColumn = columnIndex;
        currentSortDirection = 'desc';
    }
    
    applySortToTable();
}

document.getElementById('timeRange').addEventListener('change', loadChart);

// APR type toggle event listeners
document.querySelectorAll('input[name="aprType"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
        selectedAprType = e.target.value;
        loadChart();
    });
});

// Check for saved chart_id in URL and load settings
async function loadSavedChartSettings() {
    const urlParams = new URLSearchParams(window.location.search);
    const chartId = urlParams.get('chart_id');
    
    if (!chartId) return { loaded: false, chartType: null };
    
    try {
        const response = await fetch('/api/auth/charts');
        if (!response.ok) return { loaded: false, chartType: null };
        
        const charts = await response.json();
        const savedChart = charts.find(c => c.chart_id === parseInt(chartId));
        
        if (!savedChart || !savedChart.filters) return { loaded: false, chartType: null };
        
        const filters = savedChart.filters;
        const chartType = filters.chart_type || 'multi_asset';
        console.log('Loading saved chart filters:', filters, 'Type:', chartType);
        
        if (chartType === 'single_asset') {
            // Load settings for "One Asset, Multi Measures" chart
            // These will be applied after the chart is initialized
            window.savedSingleAssetFilters = filters;
            return { loaded: true, chartType: 'single_asset' };
        } else {
            // Load settings for "Multi Asset, One Measure" chart
            
            // Apply time range
            if (filters.days) {
                document.getElementById('timeRange').value = filters.days;
            }
            
            // Apply APR type (default to 30d if not specified)
            const aprType = filters.apr_type || '30d';
            console.log('Setting APR type to:', aprType);
            selectedAprType = aprType;

            // Update radio buttons
            document.querySelectorAll('input[name="aprType"]').forEach(radio => {
                radio.checked = radio.value === aprType;
            });
            
            // Apply selected assets
            if (filters.assets && filters.assets.length > 0) {
                selectedAssets.clear();
                filters.assets.forEach(symbol => {
                    selectedAssets.add(symbol);
                    const checkbox = document.getElementById(`asset-${symbol}`);
                    if (checkbox) checkbox.checked = true;
                });
                
                // Uncheck non-selected assets
                allAssets.forEach(asset => {
                    if (!filters.assets.includes(asset.symbol)) {
                        const checkbox = document.getElementById(`asset-${asset.symbol}`);
                        if (checkbox) checkbox.checked = false;
                    }
                });
                
                updateAssetLabel();
            }
            
            return { loaded: true, chartType: 'multi_asset' };
        }
    } catch (e) {
        console.error('Error loading saved chart:', e);
        return { loaded: false, chartType: null };
    }
}

// Apply saved settings for single asset chart after initialization
function applySavedSingleAssetFilters() {
    const filters = window.savedSingleAssetFilters;
    if (!filters) return;
    
    console.log('Applying saved single asset filters:', filters);
    
    // Apply time range
    if (filters.days) {
        document.getElementById('singleAssetTimeRange').value = filters.days;
    }
    
    // Apply protocols
    if (filters.protocols && filters.protocols.length > 0) {
        selectedProtocols.clear();
        allProtocolOptions.forEach(protocol => {
            const checkbox = document.getElementById(`protocol-${protocol}`);
            if (filters.protocols.includes(protocol)) {
                selectedProtocols.add(protocol);
                if (checkbox) checkbox.checked = true;
            } else {
                if (checkbox) checkbox.checked = false;
            }
        });
        updateProtocolLabel();
    }
    
    // Apply selected asset
    if (filters.selected_asset) {
        const assetSelect = document.getElementById('singleAssetSelect');
        assetSelect.value = filters.selected_asset;
    }
    
    // Load the chart with saved settings
    loadSingleAssetChart();
    
    // Scroll to the single asset chart section
    setTimeout(() => {
        const singleAssetSection = document.getElementById('singleAssetChart');
        if (singleAssetSection) {
            singleAssetSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }, 500);
    
    // Clear the saved filters
    window.savedSingleAssetFilters = null;
}

loadAssets().then(async () => {
    // Try to load saved chart settings first
    const savedResult = await loadSavedChartSettings();

    await loadChart();
    // Populate date filter and render breakdown charts after history data is loaded
    populateBreakdownDateFilter();
    setTimeout(renderBreakdownCharts, 500);

    // Initialize single asset chart
    initSingleAssetChart();
    
    // If we loaded a single_asset chart, apply its settings after initialization
    if (savedResult.loaded && savedResult.chartType === 'single_asset') {
        setTimeout(applySavedSingleAssetFilters, 100);
    }
});

// ============================================
// Single Asset, Multi Measures Chart
// ============================================
let singleAssetChart = null;
const selectedProtocols = new Set();
const versionedProtocols = ['wingriders', 'sundaeswap'];
const protocolDisplayNames = {
    'wingriders': 'WingRiders',
    'sundaeswap': 'SundaeSwap',
    'minswap': 'Minswap'
};
let allProtocolOptions = [];

function getProtocolDisplayName(protocol) {
    const parts = protocol.split('_');
    if (parts.length === 2 && versionedProtocols.includes(parts[0])) {
        const baseName = protocolDisplayNames[parts[0]] || parts[0];
        const version = parts[1].toUpperCase();
        return `${baseName} ${version}`;
    }
    return protocolDisplayNames[protocol] || protocol.charAt(0).toUpperCase() + protocol.slice(1);
}

function initSingleAssetChart() {
    const assetSelect = document.getElementById('singleAssetSelect');

    // Populate asset dropdown from allAssets
    assetSelect.innerHTML = '<option value="">Select an asset...</option>';
    allAssets.forEach(asset => {
        const option = document.createElement('option');
        option.value = asset.symbol;
        option.textContent = asset.symbol;
        assetSelect.appendChild(option);
    });

    // Set default to first NIGHT asset if available
    const nightAsset = allAssets.find(a => a.symbol.includes('NIGHT'));
    if (nightAsset) {
        assetSelect.value = nightAsset.symbol;
        updateProtocolOptionsForAsset(nightAsset.symbol);
        loadSingleAssetChart();
    }

    // Event listeners
    assetSelect.addEventListener('change', function() {
        updateProtocolOptionsForAsset(this.value);
        loadSingleAssetChart();
    });
    document.getElementById('singleAssetTimeRange').addEventListener('change', loadSingleAssetChart);

    // Protocol dropdown toggle
    document.getElementById('protocolFilterBtn').addEventListener('click', function(e) {
        e.stopPropagation();
        document.getElementById('protocolDropdown').classList.toggle('show');
        // Close asset dropdown if open
        document.getElementById('assetDropdown').classList.remove('show');
    });
}

function updateProtocolOptionsForAsset(selectedAsset) {
    // Build protocol options from allHistoryData filtered by selected asset
    const protocolVersions = new Set();

    if (selectedAsset) {
        allHistoryData
            .filter(d => d.symbol === selectedAsset)
            .forEach(d => {
                if (versionedProtocols.includes(d.protocol) && d.version) {
                    protocolVersions.add(`${d.protocol}_${d.version.toLowerCase()}`);
                } else {
                    protocolVersions.add(d.protocol);
                }
            });
    }

    allProtocolOptions = [...protocolVersions].sort();
    selectedProtocols.clear();

    // Populate protocol multi-select options
    const optionsContainer = document.getElementById('protocolOptions');
    optionsContainer.innerHTML = '';

    allProtocolOptions.forEach(protocol => {
        const div = document.createElement('div');
        div.className = 'multi-select-option';
        div.innerHTML = `
            <input type="checkbox" id="protocol-${protocol}" value="${protocol}"
                   checked onchange="toggleProtocol('${protocol}')">
            <label for="protocol-${protocol}">${getProtocolDisplayName(protocol)}</label>
        `;
        optionsContainer.appendChild(div);
        selectedProtocols.add(protocol);
    });

    updateProtocolLabel();
}

function toggleProtocol(protocol) {
    if (selectedProtocols.has(protocol)) {
        selectedProtocols.delete(protocol);
    } else {
        selectedProtocols.add(protocol);
    }
    updateProtocolLabel();
    loadSingleAssetChart();
}

function selectAllProtocols() {
    allProtocolOptions.forEach(p => selectedProtocols.add(p));
    document.querySelectorAll('#protocolOptions input').forEach(cb => cb.checked = true);
    updateProtocolLabel();
    loadSingleAssetChart();
}

function deselectAllProtocols() {
    selectedProtocols.clear();
    document.querySelectorAll('#protocolOptions input').forEach(cb => cb.checked = false);
    updateProtocolLabel();
    loadSingleAssetChart();
}

function updateProtocolLabel() {
    const count = selectedProtocols.size;
    const total = allProtocolOptions.length;
    document.getElementById('protocolCount').textContent = count;
    
    if (count === 0) {
        document.getElementById('protocolFilterLabel').textContent = 'None selected';
    } else if (count === total) {
        document.getElementById('protocolFilterLabel').textContent = 'All Protocols';
    } else if (count <= 2) {
        const names = [...selectedProtocols].map(p => getProtocolDisplayName(p)).join(', ');
        document.getElementById('protocolFilterLabel').textContent = names;
    } else {
        document.getElementById('protocolFilterLabel').textContent = `${count} selected`;
    }
}

async function loadSingleAssetChart() {
    const selectedAsset = document.getElementById('singleAssetSelect').value;
    const days = parseInt(document.getElementById('singleAssetTimeRange').value);
    
    if (!selectedAsset) {
        updateSingleAssetTable([]);
        return;
    }
    
    // Filter data for the selected asset from allHistoryData
    let assetData = allHistoryData.filter(d => d.symbol === selectedAsset);
    
    // Apply protocol filter based on multi-select
    // Build a key for each data item to match against selected protocols
    assetData = assetData.filter(d => {
        let protocolKey;
        if (versionedProtocols.includes(d.protocol) && d.version) {
            protocolKey = `${d.protocol}_${d.version.toLowerCase()}`;
        } else {
            protocolKey = d.protocol;
        }
        return selectedProtocols.has(protocolKey);
    });
    
    if (assetData.length === 0) {
        updateSingleAssetTable([]);
        return;
    }
    
    // Process data for each protocol that has this asset
    const datasets = [];
    const tableData = [];
    
    // Protocol colors - assign unique color per protocol+version
    const protocolColors = [
        '#16a34a',   // Green
        '#d97706',   // Orange
        '#2563eb',   // Blue
        '#0891b2',   // Cyan
        '#dc2626',   // Red
        '#9333ea'    // Purple
    ];
    
    // Build a unique key for each protocol+version and assign a unique color
    const protocolVersionMap = {};
    let colorIndex = 0;
    assetData.forEach(protocolData => {
        const protocol = protocolData.protocol;
        const version = protocolData.version;
        const key = version ? `${protocol}_${version.toLowerCase()}` : protocol;
        
        if (!protocolVersionMap[key]) {
            protocolVersionMap[key] = {
                color: protocolColors[colorIndex % protocolColors.length]
            };
            colorIndex++;
        }
    });
    
    // Measure styles: shape AND line style distinguish each measure type
    const measureStyles = {
        '1d': { dash: [], width: 2, pointStyle: 'circle' },           // Solid line, circle
        '7d': { dash: [6, 4], width: 2.5, pointStyle: 'triangle' },   // Dashed line, triangle
        '30d': { dash: [2, 2], width: 3, pointStyle: 'rect' }         // Dotted line, square
    };
    
    assetData.forEach((protocolData) => {
        const protocol = protocolData.protocol;
        const version = protocolData.version;
        const rawData = protocolData.data.filter(d => d.apr_1d != null);
        
        if (rawData.length === 0) return;
        
        // Sort by timestamp
        rawData.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        
        // Calculate rolling averages
        const processed = calculateRollingAverages(rawData, days);
        
        const versionSuffix = version ? ` ${version}` : '';
        const label = `${protocol}${versionSuffix}`;
        
        // Get unique color for this protocol+version combination
        const key = version ? `${protocol}_${version.toLowerCase()}` : protocol;
        const protocolColor = protocolVersionMap[key].color;
        
        ['1d', '7d', '30d'].forEach((avgType) => {
            const style = measureStyles[avgType];
            datasets.push({
                label: `${label} (${avgType} avg)`,
                data: processed.map(d => ({ x: new Date(d.timestamp), y: d[`avg_${avgType}`] })),
                borderColor: protocolColor,
                backgroundColor: protocolColor + '20',
                borderWidth: style.width,
                borderDash: style.dash,
                pointStyle: style.pointStyle,
                tension: 0.4,
                fill: false
            });
        });
        
        // Get latest values for table
        const latest = processed[processed.length - 1];
        if (latest) {
            tableData.push({
                protocol: label,
                color: protocolColor,
                avg1d: latest.avg_1d,
                avg7d: latest.avg_7d,
                avg30d: latest.avg_30d,
                dataPoints: rawData.length
            });
        }
    });
    
    // Render chart
    if (singleAssetChart) {
        singleAssetChart.destroy();
    }
    
    const ctx = document.getElementById('singleAssetChart').getContext('2d');
    singleAssetChart = new Chart(ctx, {
        type: 'line',
        data: { datasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: true,
                    labels: {
                        color: '#1a1a1a',
                        usePointStyle: true,
                        padding: 15,
                        font: { size: 11 }
                    }
                },
                tooltip: {
                    callbacks: {
                        label: (context) => `${context.dataset.label}: ${context.parsed.y.toFixed(2)}%`
                    }
                }
            },
            scales: {
                x: {
                    type: 'time',
                    time: { unit: days <= 30 ? 'day' : 'week' },
                    grid: { color: 'rgba(0, 0, 0, 0.1)' },
                    ticks: { color: '#1a1a1a' }
                },
                y: {
                    beginAtZero: true,
                    grid: { color: 'rgba(0, 0, 0, 0.1)' },
                    ticks: {
                        color: '#1a1a1a',
                        callback: (value) => value + '%'
                    }
                }
            }
        }
    });
    
    updateSingleAssetTable(tableData);
}

function calculateRollingAverages(data, maxDays) {
    const result = [];
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - maxDays);
    
    // Filter to time range
    const filteredData = data.filter(d => new Date(d.timestamp) >= cutoffDate);
    
    // If not enough data, extrapolate by repeating available data pattern
    let workingData = filteredData;
    if (filteredData.length < 7 && data.length > 0) {
        // Use all available data and extrapolate
        workingData = data.slice(-Math.min(data.length, 30));
    }
    
    workingData.forEach((point, i) => {
        const timestamp = point.timestamp;
        const apr1d = point.apr_1d;
        
        // 1-day average is just the current value
        const avg1d = apr1d;
        
        // 7-day rolling average
        const last7 = workingData.slice(Math.max(0, i - 6), i + 1);
        let avg7d;
        if (last7.length >= 7) {
            avg7d = last7.reduce((sum, p) => sum + p.apr_1d, 0) / last7.length;
        } else {
            // Extrapolate: use available data average
            avg7d = last7.reduce((sum, p) => sum + p.apr_1d, 0) / last7.length;
        }
        
        // 30-day rolling average
        const last30 = workingData.slice(Math.max(0, i - 29), i + 1);
        let avg30d;
        if (last30.length >= 30) {
            avg30d = last30.reduce((sum, p) => sum + p.apr_1d, 0) / last30.length;
        } else {
            // Extrapolate: use available data average
            avg30d = last30.reduce((sum, p) => sum + p.apr_1d, 0) / last30.length;
        }
        
        result.push({
            timestamp,
            avg_1d: avg1d,
            avg_7d: avg7d,
            avg_30d: avg30d
        });
    });
    
    return result;
}

function getShapeSvg(pointStyle, color) {
    // Generate SVG for each Chart.js point style
    const size = 14;
    const half = size / 2;
    
    switch (pointStyle) {
        case 'circle':
            return `<svg width="${size}" height="${size}" style="vertical-align: middle; margin-right: 8px;">
                <circle cx="${half}" cy="${half}" r="${half - 1}" fill="${color}"/>
            </svg>`;
        case 'triangle':
            return `<svg width="${size}" height="${size}" style="vertical-align: middle; margin-right: 8px;">
                <polygon points="${half},1 ${size - 1},${size - 1} 1,${size - 1}" fill="${color}"/>
            </svg>`;
        case 'rect':
            return `<svg width="${size}" height="${size}" style="vertical-align: middle; margin-right: 8px;">
                <rect x="1" y="1" width="${size - 2}" height="${size - 2}" fill="${color}"/>
            </svg>`;
        case 'rectRot': // Diamond
            return `<svg width="${size}" height="${size}" style="vertical-align: middle; margin-right: 8px;">
                <polygon points="${half},1 ${size - 1},${half} ${half},${size - 1} 1,${half}" fill="${color}"/>
            </svg>`;
        case 'star':
            return `<svg width="${size}" height="${size}" style="vertical-align: middle; margin-right: 8px;">
                <polygon points="7,1 8.5,5 13,5.5 9.5,8.5 10.5,13 7,10.5 3.5,13 4.5,8.5 1,5.5 5.5,5" fill="${color}"/>
            </svg>`;
        case 'crossRot': // X shape
            return `<svg width="${size}" height="${size}" style="vertical-align: middle; margin-right: 8px;">
                <path d="M2,2 L12,12 M12,2 L2,12" stroke="${color}" stroke-width="3" stroke-linecap="round"/>
            </svg>`;
        case 'rectRounded':
            return `<svg width="${size}" height="${size}" style="vertical-align: middle; margin-right: 8px;">
                <rect x="1" y="1" width="${size - 2}" height="${size - 2}" rx="3" ry="3" fill="${color}"/>
            </svg>`;
        case 'cross':
            return `<svg width="${size}" height="${size}" style="vertical-align: middle; margin-right: 8px;">
                <path d="M${half},2 L${half},${size - 2} M2,${half} L${size - 2},${half}" stroke="${color}" stroke-width="3" stroke-linecap="round"/>
            </svg>`;
        default:
            return `<svg width="${size}" height="${size}" style="vertical-align: middle; margin-right: 8px;">
                <circle cx="${half}" cy="${half}" r="${half - 1}" fill="${color}"/>
            </svg>`;
    }
}

function updateSingleAssetTable(data) {
    const tbody = document.getElementById('singleAssetTableBody');
    
    if (data.length === 0) {
        tbody.innerHTML = '<tr><td colspan="4" class="text-center" style="color: #555;">Select an asset to view data</td></tr>';
        return;
    }
    
    tbody.innerHTML = data.map(row => {
        // Extract base protocol name for logo lookup (remove version suffix)
        const baseProtocol = row.protocol.split(' ')[0].toLowerCase();
        const logo = protocolLogos[baseProtocol] || '/static/default-logo.png';
        
        return `
        <tr>
            <td>
                <img src="${logo}" alt="${row.protocol}" style="width: 20px; height: 20px; margin-right: 8px; vertical-align: middle; border-radius: 4px;" onerror="this.style.display='none'">
                <strong>${row.protocol}</strong>
            </td>
            <td style="color: var(--carbon-black); font-weight: 600;">
                ${getShapeSvg('circle', row.color)}
                ${row.avg1d?.toFixed(2) || '-'}%
            </td>
            <td style="color: var(--carbon-black); font-weight: 600;">
                ${getShapeSvg('triangle', row.color)}
                ${row.avg7d?.toFixed(2) || '-'}%
            </td>
            <td style="color: var(--carbon-black); font-weight: 600;">
                ${getShapeSvg('rect', row.color)}
                ${row.avg30d?.toFixed(2) || '-'}%
            </td>
        </tr>
    `}).join('');
}

// Save Chart functionality
function saveCurrentChart() {
    {% if current_user.is_authenticated %}
    document.getElementById('chartType').value = 'multi_asset';
    document.getElementById('chartTypeIndicator').innerHTML = 'üìä Saving: <strong>Multi Asset, One Measure</strong> chart';
    document.getElementById('chartName').value = 'Cardano LP Chart';
    new bootstrap.Modal(document.getElementById('saveChartModal')).show();
    {% else %}
    new bootstrap.Modal(document.getElementById('authModal')).show();
    {% endif %}
}

function saveSingleAssetChart() {
    {% if current_user.is_authenticated %}
    const selectedAsset = document.getElementById('singleAssetSelect').value;
    document.getElementById('chartType').value = 'single_asset';
    document.getElementById('chartTypeIndicator').innerHTML = 'üìà Saving: <strong>One Asset, Multi Measures</strong> chart';
    document.getElementById('chartName').value = selectedAsset ? `${selectedAsset} Analysis` : 'Single Asset Chart';
    new bootstrap.Modal(document.getElementById('saveChartModal')).show();
    {% else %}
    new bootstrap.Modal(document.getElementById('authModal')).show();
    {% endif %}
}

async function handleSaveChart(event) {
    event.preventDefault();
    
    const name = document.getElementById('chartName').value;
    const chartType = document.getElementById('chartType').value;
    const alert = document.getElementById('saveChartAlert');
    
    let filters;
    
    if (chartType === 'single_asset') {
        // Save settings for "One Asset, Multi Measures" chart
        filters = {
            chain: chain,
            chart_type: 'single_asset',
            days: parseInt(document.getElementById('singleAssetTimeRange').value),
            selected_asset: document.getElementById('singleAssetSelect').value,
            protocols: Array.from(selectedProtocols),
            yield_type: yieldType
        };
    } else {
        // Save settings for "Multi Asset, One Measure" chart
        filters = {
            chain: chain,
            chart_type: 'multi_asset',
            days: parseInt(document.getElementById('timeRange').value),
            assets: Array.from(selectedAssets),
            yield_type: yieldType,
            apr_type: selectedAprType
        };
    }
    
    try {
        const response = await fetch('/api/auth/charts', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name, filters })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            alert.textContent = 'Chart saved successfully!';
            alert.className = 'alert alert-success';
            alert.classList.remove('d-none');
            
            setTimeout(() => {
                bootstrap.Modal.getInstance(document.getElementById('saveChartModal')).hide();
                alert.classList.add('d-none');
            }, 1500);
        } else {
            alert.textContent = data.error || 'Failed to save chart';
            alert.className = 'alert alert-danger';
            alert.classList.remove('d-none');
        }
    } catch (e) {
        alert.textContent = 'Connection error. Please try again.';
        alert.className = 'alert alert-danger';
        alert.classList.remove('d-none');
    }
}

// Breakdown pie charts
const breakdownCharts = {};
const breakdownProtocolData = {}; // Store per-protocol data for filtering
let breakdownAvailableDates = []; // Store available dates for the breakdown filter

function populateBreakdownDateFilter() {
    // Collect all unique dates from allHistoryData
    const dateSet = new Set();
    allHistoryData.forEach(assetData => {
        if (assetData.data && assetData.data.length > 0) {
            assetData.data.forEach(d => {
                if (d.timestamp) {
                    // Extract just the date part (YYYY-MM-DD)
                    const dateStr = d.timestamp.split('T')[0];
                    dateSet.add(dateStr);
                }
            });
        }
    });

    // Sort dates descending (most recent first)
    breakdownAvailableDates = [...dateSet].sort((a, b) => b.localeCompare(a));

    const dateSelect = document.getElementById('breakdownDateFilter');
    if (!dateSelect || breakdownAvailableDates.length === 0) return;

    dateSelect.innerHTML = breakdownAvailableDates.map((date, idx) => {
        const displayDate = new Date(date + 'T00:00:00').toLocaleDateString('en-US', {
            month: 'short', day: 'numeric', year: 'numeric'
        });
        return `<option value="${date}"${idx === 0 ? ' selected' : ''}>${displayDate}</option>`;
    }).join('');
}

// Protocol colors - consistent across all protocols
const protocolBreakdownColors = {
    'minswap': {
        fees: '#0E8749',
        farm: '#F74B03'
    },
    'sundaeswap': {
        fees: '#0E8749',
        farm: '#F74B03'
    },
    'wingriders': {
        fees: '#0E8749',
        staking: '#06b6d4',
        farm: '#F74B03'
    }
};

function renderBreakdownCharts() {
    const container = document.getElementById('breakdownCharts');

    if (!allHistoryData || allHistoryData.length === 0) {
        container.innerHTML = `
            <div class="col-12">
                <div class="breakdown-loading">
                    <span>No data available for breakdown</span>
                </div>
            </div>
        `;
        return;
    }

    // Get selected date from filter (or use latest)
    const dateSelect = document.getElementById('breakdownDateFilter');
    const selectedDate = dateSelect ? dateSelect.value : null;

    // Group data by protocol and calculate breakdown
    const protocolBreakdowns = {};

    allHistoryData.forEach(assetData => {
        const protocol = assetData.protocol;

        // Find data for selected date, or use latest if not found
        let targetData = null;
        if (selectedDate && assetData.data && assetData.data.length > 0) {
            targetData = assetData.data.find(d => d.timestamp && d.timestamp.startsWith(selectedDate));
        }
        if (!targetData) {
            targetData = assetData.data[assetData.data.length - 1];
        }

        if (!targetData) return;
        
        if (!protocolBreakdowns[protocol]) {
            protocolBreakdowns[protocol] = {
                protocol: protocol,
                pools: [],
                totalTvl: 0,
                totalFeeApr: 0,
                totalFarmApr: 0
            };
        }
        
        const tvl = targetData.tvl_usd || 0;
        const apr = targetData.apr || 0;      // 30-day APR (total for SundaeSwap)
        const apr1d = targetData.apr_1d || 0; // 1-day APR
        const fees24h = targetData.fees_24h || 0;

        let feeApr = 0;
        let farmApr = 0;
        let totalApr = 0;

        // Protocol-specific breakdown logic
        if (protocol === 'sundaeswap') {
            // SundaeSwap: apr_1d = HRA (fees only), apr = total (fees + SUNDAE farming)
            feeApr = apr1d;
            farmApr = Math.max(0, apr - apr1d);
            totalApr = apr;
        } else if (protocol === 'minswap') {
            // Minswap: apr_1d = total (fees + MIN farming), calculate fees from fees_24h
            if (tvl > 0 && fees24h > 0) {
                feeApr = (fees24h / tvl) * 365 * 100;
            }
            farmApr = Math.max(0, apr1d - feeApr);
            totalApr = apr1d > 0 ? apr1d : apr;
        } else if (protocol === 'wingriders') {
            // WingRiders: use stored breakdown if available, otherwise fallback
            if (targetData.fee_apr != null) {
                feeApr = targetData.fee_apr;
                farmApr = targetData.farm_apr || 0;
                totalApr = apr; // Use stored total
            } else {
                // Fallback for old data without breakdown
                feeApr = apr;
                farmApr = 0;
                totalApr = apr;
            }
        } else {
            // Default fallback
            if (tvl > 0 && fees24h > 0) {
                feeApr = (fees24h / tvl) * 365 * 100;
                farmApr = Math.max(0, (apr1d || apr) - feeApr);
            } else {
                feeApr = apr1d || apr;
                farmApr = 0;
            }
            totalApr = apr1d || apr;
        }
        
        // Track staking APR separately for WingRiders
        const stakingApr = (protocol === 'wingriders' && targetData.staking_apr != null)
            ? targetData.staking_apr
            : 0;

        // Swap fee percentage from API (e.g., 0.30 for 0.30%)
        const swapFeePercent = targetData.swap_fee_percent || null;
        
        protocolBreakdowns[protocol].pools.push({
            symbol: assetData.symbol,
            tvl: tvl,
            feeApr: feeApr,
            stakingApr: stakingApr,
            farmApr: farmApr,
            totalApr: totalApr,
            swapFeePercent: swapFeePercent
        });
        
        protocolBreakdowns[protocol].totalTvl += tvl;
    });
    
    // Calculate TVL-weighted averages for each protocol
    const protocolData = Object.values(protocolBreakdowns).map(p => {
        let weightedFeeApr = 0;
        let weightedStakingApr = 0;
        let weightedFarmApr = 0;
        
        if (p.totalTvl > 0) {
            p.pools.forEach(pool => {
                const weight = pool.tvl / p.totalTvl;
                weightedFeeApr += pool.feeApr * weight;
                weightedStakingApr += (pool.stakingApr || 0) * weight;
                weightedFarmApr += pool.farmApr * weight;
            });
        } else if (p.pools.length > 0) {
            // Simple average if no TVL data
            weightedFeeApr = p.pools.reduce((sum, pool) => sum + pool.feeApr, 0) / p.pools.length;
            weightedStakingApr = p.pools.reduce((sum, pool) => sum + (pool.stakingApr || 0), 0) / p.pools.length;
            weightedFarmApr = p.pools.reduce((sum, pool) => sum + pool.farmApr, 0) / p.pools.length;
        }
        
        // Calculate TVL-weighted average swap fee for "All Pools" display
        let weightedSwapFee = null;
        const poolsWithSwapFee = p.pools.filter(pool => pool.swapFeePercent != null);
        if (poolsWithSwapFee.length > 0) {
            const totalTvlWithFee = poolsWithSwapFee.reduce((sum, pool) => sum + pool.tvl, 0);
            if (totalTvlWithFee > 0) {
                weightedSwapFee = poolsWithSwapFee.reduce((sum, pool) => {
                    const weight = pool.tvl / totalTvlWithFee;
                    return sum + (pool.swapFeePercent * weight);
                }, 0);
            } else {
                // Simple average if no TVL data
                weightedSwapFee = poolsWithSwapFee.reduce((sum, pool) => sum + pool.swapFeePercent, 0) / poolsWithSwapFee.length;
            }
        }
        
        return {
            protocol: p.protocol,
            poolCount: p.pools.length,
            totalTvl: p.totalTvl,
            pools: p.pools, // Include pools for dropdown filter
            feeApr: weightedFeeApr,
            stakingApr: weightedStakingApr,
            farmApr: weightedFarmApr,
            totalApr: weightedFeeApr + weightedStakingApr + weightedFarmApr,
            swapFeePercent: weightedSwapFee
        };
    }).filter(p => p.totalApr > 0);
    
    // Sort protocols in desired order: Minswap, SundaeSwap, WingRiders
    const protocolOrder = ['minswap', 'sundaeswap', 'wingriders'];
    protocolData.sort((a, b) => {
        const aIndex = protocolOrder.indexOf(a.protocol);
        const bIndex = protocolOrder.indexOf(b.protocol);
        return (aIndex === -1 ? 999 : aIndex) - (bIndex === -1 ? 999 : bIndex);
    });
    
    if (protocolData.length === 0) {
        container.innerHTML = `
            <div class="col-12">
                <div class="breakdown-loading">
                    <span>No breakdown data available</span>
                </div>
            </div>
        `;
        return;
    }
    
    // Store protocol data for filtering and build cards HTML
    let html = '';
    protocolData.forEach((data, index) => {
        // Store for later use
        breakdownProtocolData[index] = data;
        
        const colors = protocolBreakdownColors[data.protocol] || { fees: '#0E8749', farm: '#F74B03' };
        const logo = protocolLogos[data.protocol] || '';
        
        // Build pool options for dropdown (sorted by total APR descending)
        const sortedPools = [...data.pools].sort((a, b) => b.totalApr - a.totalApr);
        const poolOptions = sortedPools.map(p => 
            `<option value="${p.symbol}">${p.symbol} (${p.totalApr.toFixed(1)}%)</option>`
        ).join('');
        
        html += `
            <div class="breakdown-card-wrapper mb-3">
                <div class="breakdown-card-header">
                    <img src="${logo}" alt="${data.protocol}" onerror="this.style.display='none'">
                    <h5>${data.protocol}</h5>
                    <span class="breakdown-card-meta">${data.poolCount} pools</span>
                </div>
                <div class="breakdown-filter">
                    <select id="breakdownFilter${index}" onchange="updateBreakdownChart(${index})">
                        <option value="all">All Pools (TVL-weighted avg)</option>
                        ${poolOptions}
                    </select>
                </div>
                <div class="breakdown-content">
                    <div class="breakdown-chart-container">
                        <canvas id="breakdownChart${index}"></canvas>
                        <div class="breakdown-chart-center" id="breakdownChartCenter${index}">
                            <!-- Swap fee displayed here -->
                        </div>
                    </div>
                    <div class="breakdown-legend" id="breakdownLegend${index}">
                        <!-- Legend populated by JS -->
                    </div>
                </div>
            </div>
        `;
    });
    
    container.innerHTML = html;
    
    // Initial render of all charts with "All Pools" selected
    protocolData.forEach((data, index) => {
        updateBreakdownChart(index);
    });
}

function updateBreakdownChart(index) {
    const data = breakdownProtocolData[index];
    if (!data) return;
    
    const filterSelect = document.getElementById(`breakdownFilter${index}`);
    const selectedValue = filterSelect ? filterSelect.value : 'all';
    
    let displayData;
    
    if (selectedValue === 'all') {
        // Use TVL-weighted averages
        displayData = {
            feeApr: data.feeApr,
            stakingApr: data.stakingApr,
            farmApr: data.farmApr,
            totalApr: data.totalApr,
            swapFeePercent: data.swapFeePercent
        };
    } else {
        // Find the specific pool
        const pool = data.pools.find(p => p.symbol === selectedValue);
        if (pool) {
            displayData = {
                feeApr: pool.feeApr,
                stakingApr: pool.stakingApr || 0,
                farmApr: pool.farmApr,
                totalApr: pool.totalApr,
                swapFeePercent: pool.swapFeePercent
            };
        } else {
            displayData = { feeApr: 0, stakingApr: 0, farmApr: 0, totalApr: 0, swapFeePercent: null };
        }
    }
    
    // Update center text with swap fee
    const centerContainer = document.getElementById(`breakdownChartCenter${index}`);
    if (centerContainer) {
        if (displayData.swapFeePercent != null) {
            centerContainer.innerHTML = `
                <div class="swap-fee-label">Swap Fee</div>
                <div class="swap-fee-value">${displayData.swapFeePercent.toFixed(2)}%</div>
            `;
        } else {
            centerContainer.innerHTML = '';
        }
    }
    
    const colors = protocolBreakdownColors[data.protocol] || { fees: '#0E8749', farm: '#F74B03' };
    
    // Update legend
    const legendContainer = document.getElementById(`breakdownLegend${index}`);
    if (legendContainer) {
        const hasStaking = displayData.stakingApr > 0.01;
        const hasFarm = displayData.farmApr > 0.01;
        
        legendContainer.innerHTML = `
            <div class="breakdown-legend-item">
                <span class="breakdown-legend-color" style="background: ${colors.fees}"></span>
                <span class="breakdown-legend-label">Trading Fees</span>
                <span class="breakdown-legend-value">${displayData.feeApr.toFixed(2)}%</span>
            </div>
            ${hasStaking ? `
            <div class="breakdown-legend-item">
                <span class="breakdown-legend-color" style="background: ${colors.staking || '#06b6d4'}"></span>
                <span class="breakdown-legend-label">${data.protocol === 'wingriders' ? 'NFT Bonus' : 'ADA Staking'}</span>
                <span class="breakdown-legend-value">${displayData.stakingApr.toFixed(2)}%</span>
            </div>
            ` : ''}
            ${hasFarm ? `
            <div class="breakdown-legend-item">
                <span class="breakdown-legend-color" style="background: ${colors.farm}"></span>
                <span class="breakdown-legend-label">Farm Rewards</span>
                <span class="breakdown-legend-value">${displayData.farmApr.toFixed(2)}%</span>
            </div>
            ` : ''}
            <div class="breakdown-legend-item" style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(0,0,0,0.08);">
                <span class="breakdown-legend-color" style="background: transparent"></span>
                <span class="breakdown-legend-label"><strong>Total APR</strong></span>
                <span class="breakdown-legend-value" style="color: var(--sea-green);">${displayData.totalApr.toFixed(2)}%</span>
            </div>
        `;
    }
    
    // Update chart
    const ctx = document.getElementById(`breakdownChart${index}`);
    if (!ctx) return;
    
    // Destroy existing chart if any
    if (breakdownCharts[index]) {
        breakdownCharts[index].destroy();
    }
    
    // Build chart data dynamically based on what components exist
    const chartData = [];
    const chartColors = [];
    const chartLabels = [];
    
    // Always include fees if > 0
    if (displayData.feeApr > 0.001) {
        chartData.push(displayData.feeApr);
        chartColors.push(colors.fees);
        chartLabels.push('Trading Fees');
    }
    
    // Include staking if significant (WingRiders)
    if (displayData.stakingApr > 0.01) {
        chartData.push(displayData.stakingApr);
        chartColors.push(colors.staking || '#06b6d4');
        chartLabels.push(data.protocol === 'wingriders' ? 'NFT Bonus' : 'ADA Staking');
    }
    
    // Include farm rewards if significant
    if (displayData.farmApr > 0.01) {
        chartData.push(displayData.farmApr);
        chartColors.push(colors.farm);
        chartLabels.push('Farm Rewards');
    }
    
    // Skip if no data
    if (chartData.length === 0) {
        chartData.push(1);
        chartColors.push('#e5e7eb');
        chartLabels.push('No Data');
    }
    
    breakdownCharts[index] = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: chartLabels,
            datasets: [{
                data: chartData,
                backgroundColor: chartColors,
                borderColor: 'rgba(255,255,255,0.9)',
                borderWidth: 2,
                hoverOffset: 8,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            cutout: '55%',
            plugins: {
                legend: {
                    display: false,
                },
                tooltip: {
                    enabled: false,
                    external: function(context) {
                        const tooltipEl = document.getElementById('pieChartTooltip');
                        const tooltipModel = context.tooltip;
                        
                        // Hide if no tooltip
                        if (tooltipModel.opacity === 0) {
                            tooltipEl.classList.remove('visible');
                            return;
                        }
                        
                        // Set content
                        if (tooltipModel.body) {
                            const dataIndex = tooltipModel.dataPoints[0].dataIndex;
                            const label = tooltipModel.dataPoints[0].label;
                            const value = tooltipModel.dataPoints[0].raw;
                            
                            if (label === 'No Data') {
                                tooltipEl.innerHTML = 'No breakdown data';
                            } else {
                                const total = tooltipModel.dataPoints[0].dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = ((value / total) * 100).toFixed(1);
                                tooltipEl.innerHTML = `<strong>${label}</strong><br>${value.toFixed(2)}% (${percentage}% of total)`;
                            }
                        }
                        
                        // Position tooltip
                        const canvas = context.chart.canvas;
                        const rect = canvas.getBoundingClientRect();
                        tooltipEl.style.left = (rect.left + window.scrollX + tooltipModel.caretX + 10) + 'px';
                        tooltipEl.style.top = (rect.top + window.scrollY + tooltipModel.caretY - 10) + 'px';
                        tooltipEl.classList.add('visible');
                    }
                }
            },
            animation: {
                animateScale: true,
                animateRotate: true,
                duration: 500,
                easing: 'easeOutQuart'
            }
        }
    });
}
</script>
{% endblock %}

